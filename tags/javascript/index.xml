<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>javascript on KMS&#39;s blog</title>
    <link>https://kms-97.github.io/tags/javascript/</link>
    <description>Recent content in javascript on KMS&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <managingEditor>개별설정 (개별설정)</managingEditor>
    <webMaster>개별설정 (개별설정)</webMaster>
    <lastBuildDate>Wed, 15 Sep 2021 10:40:00 +0900</lastBuildDate><atom:link href="https://kms-97.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Javscript - 객체</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EA%B0%9D%EC%B2%B4/</link>
      <pubDate>Wed, 15 Sep 2021 10:40:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EA%B0%9D%EC%B2%B4/</guid>
      <description>객체 선언 const obj = new Object() const obj = {} 두 방법에 큰 차이는 없으나 객체 리터럴 방법(2번째)이 가독성과 성능 등의 이유로 권장됨
프로퍼티 생성 const person = { name: &amp;#39;kim&amp;#39;, age: 25, } // 선언 시 입력  person.bloodtype = &amp;#39;A&amp;#39; // 동적 선언 프로퍼티의 값으로는 어떤 자료형이든 가능
const person ={ name: &amp;#39;kim&amp;#39;, age: 25, live: true, friends: [&amp;#39;song&amp;#39;, &amp;#39;ho&amp;#39;, &amp;#39;kang&amp;#39;], say: function(word) { alert(`${this.name}: ${word}`) } } 프로퍼티 접근 const person = { name: &amp;#39;kim&amp;#39;, age: 25, } person.</description>
    </item>
    
    <item>
      <title>Javscript - 함수</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%ED%95%A8%EC%88%98/</link>
      <pubDate>Wed, 15 Sep 2021 10:40:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%ED%95%A8%EC%88%98/</guid>
      <description>함수 자바스크립트에서 함수는 기본적인 구성 블럭 중 하나
함수 사용을 위해서는 함수를 호출하고자 하는 범위 내에서 정의해야함
선언 선언문 function 함수명(매개변수) { 함수 식 return 반환값 } 표현식 let myFucn = function(매개변수) { 함수 식 return 반환값 } 화살표 함수 표현식 let myFunc = (매개변수) =&amp;gt; { 함수 식 return 반환값 } let myFunc = 변수 =&amp;gt; 결과 // 인자가 하나라면 괄호 생략 가능 함수 선언문은 호이스팅되지만, 표현식은 인터프리터가 해당 줄에 도달해야 로드됨</description>
    </item>
    
    <item>
      <title>Javscript - 연산자</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EC%97%B0%EC%82%B0%EC%9E%90/</link>
      <pubDate>Wed, 15 Sep 2021 01:40:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EC%97%B0%EC%82%B0%EC%9E%90/</guid>
      <description>이항 연산자    연산자 설명 예시     + 덧셈 연산자 2 + 3   - 뺄셈 연산자 7 - 2   * 곱셈 연산자 5 * 1   / 나눗셈 연산자 35 / 7   % 나머지 연산자 41 % 6   ** 제곱 연산자 3 ** 2    단항 연산자    연산자 설명 예시     + 단항 덧셈 연산자 +2</description>
    </item>
    
    <item>
      <title>Javscript - 자료형</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EC%9E%90%EB%A3%8C%ED%98%95/</link>
      <pubDate>Wed, 15 Sep 2021 01:40:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EC%9E%90%EB%A3%8C%ED%98%95/</guid>
      <description>원시형 숫자형 (2^53-1)부터 -(2^53-1)사이의 정수와 부동소수점 방식으로 표현된 실수
const int = 3; // 정수 선언 const float = 7.12; // 실수 선언 const floatToInt = parseInt(float); // 7 const intTofloat = int.toFixed(3); // &amp;#34;3.000&amp;#34; const StringToFloat = parseFloat(&amp;#39;6.84px&amp;#39;); // 6.84 const StringToInt = parseInt(&amp;#39;6.84px&amp;#39;); // 6 무한대(Infinity) Infinity 또는 -Infinity로 표현
const inf = 3/0; // Infinity const infDeclare = Infinity // 선언 inf === Infinify // true // 판별 isFinite(inf) // false NaN 아래의 경우 NaN을 반환</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(5) - 점수 올리기</title>
      <link>https://kms-97.github.io/project/react_blockgame5/</link>
      <pubDate>Mon, 13 Sep 2021 19:10:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame5/</guid>
      <description>점수 기능 구현 게임판의 칸이 세로 또는 가로로 한 줄이 전부 채워지면 해당 줄을 지우고 점수를 올려야한다.
점수 관리 GameData.js
import React, { useState, createContext } from &amp;#34;react&amp;#34;; const GameDataContext = createContext({ state: { gamemode : 7, score : 0 }, actions : { setGamemode: () =&amp;gt; {}, setScore: () =&amp;gt; {}, } }) const GameDataProvider = ({ children }) =&amp;gt; { const [gamemode, setGamemode] = useState(7) const [score, setScore] = useState(0) const context = { state : { gamemode, score }, actions : { setGamemode, setScore } } return ( &amp;lt;GameDataContext.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(4) - 블럭 넣기 구현</title>
      <link>https://kms-97.github.io/project/react_blockgame4/</link>
      <pubDate>Sun, 12 Sep 2021 21:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame4/</guid>
      <description>게임판 상호작용 블럭을 드래그&amp;amp;드롭 할 때, 게임판 위에 위치하는지와 어느 칸에 삽입하는지를 알기 위해 게임판의 좌표를 가져와야할 필요가 있다.
ObjectList.js
... useEffect(() =&amp;gt; { const container = document.getElementById(&amp;#34;top-gameboard-container&amp;#34;) const boundary = container.getBoundingClientRect() return ( console.log(boundary) // 확인용  ) } ) ... useEffect를 사용하여 DOM이 렌더링되고 난 이후 게임판의 좌표를 getBoundingCilentRect() 통해서 가져오고자 했다.
결과는 에러였는데, 서로 다른 컴포넌트에서 렌더링되어 useEffect로 접근이 불가능한 듯하다. 이를 해결하기 위해서 context를 통한 전역변수로 사용하고자 했는데, 게임판의 좌표 외에 각 격자마다의 좌표, 삽입할 경우의 style 또는 state 변경 등을 생각하면 모두 context로 전달하기에는 너무 복잡해질 것 같았다.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(3) - 블럭 만들기</title>
      <link>https://kms-97.github.io/project/react_blockgame3/</link>
      <pubDate>Thu, 09 Sep 2021 05:31:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame3/</guid>
      <description>블럭 오브젝트 만들기 줄곧 빈 칸으로 있던 ObjectList.js를 먼저 채워주기로 했다. 하나의 파일 안에 코드를 몰아넣으면 복잡해질 것 같아 생성하는 함수는 따로 작성하여 import 해주기로 했다.
ObjectUtil.js
const blockShape = [ [[1]], [[0,1],[1,1]], [[1,1],[1,1]], [[1,0,0],[1,1,1]], [[0,1,0],[1,1,1]], [[0,0,1],[1,1,1]], [[0,0,1],[0,0,1],[1,1,1]], [[1,1,1],[1,1,1],[1,1,1]], ] // 블럭 모양 설정  const blockColor = [ &amp;#39;black&amp;#39;, &amp;#39;gray&amp;#39;, &amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;purple&amp;#39;, &amp;#39;yellowgreen&amp;#39; ] // 블럭 색깔 설정  const rotate = [ 0, 90, 180, 270 ] // 블럭 회전  const randomNumber = () =&amp;gt; { return ({ shape: Math.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(2) - Context API</title>
      <link>https://kms-97.github.io/project/react_blockgame2/</link>
      <pubDate>Thu, 09 Sep 2021 05:30:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame2/</guid>
      <description>Context API 도입 (1)에서 만들었던 화면에서는 게임 모드를 선택해도 게임판의 격자가 바뀌지 않았다. Gamemode.js의 state가 Gameboard.js로 전달되지 않아서인데, state를 공통 상위 컴포넌트로 올려도 되지만 이후 게임판의 좌표를 통해서 드래그&amp;amp;드롭되는 위치를 확인할 계획이기 때문에 컴포넌트 간 여러 변수를 공유할 계획으로 전역변수를 위한 Context API를 사용해 보기로 했다.
context/GameData.js
const GameDataContext = createContext({ state: { gamemode : 7, }, actions : { setGamemode: () =&amp;gt; {}, } }) const GameDataProvider = ({ children }) =&amp;gt; { const [gamemode, setGamemode] = useState(7) const context = { state : { gamemode }, actions : { setGamemode } } return ( &amp;lt;GameDataContext.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(1) - 시작, 화면 구성</title>
      <link>https://kms-97.github.io/project/react_blockgame1/</link>
      <pubDate>Mon, 06 Sep 2021 23:50:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame1/</guid>
      <description>시작 지난 번 작혼 확장프로그램을 리액트로 만들어 본 이후, 리액트와 자바스크립트에 좀 더 익숙해지고자 새로 시도해 볼 토이프로젝트를 고심하던 중 모바일 게임을 보고 구현해보고자 한다.
구상  게임 모드 버튼을 통해 게임판 크기 변경 가능 랜덤으로 생성되는 3가지의 블록을 드래그&amp;amp;드롭을 통해 배치 가로 또는 세로 한 줄이 다 차면 삭제 배치된 블럭 수, 삭제된 라인 또는 블럭 수 등으로 점수 표시  화면 구현 우선 간단하게 화면을 구성해보았다. 하나하나 기능을 구현해 갈 예정이다.</description>
    </item>
    
  </channel>
</rss>
