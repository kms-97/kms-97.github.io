<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KMS&#39;s blog</title>
    <link>https://kms-97.github.io/</link>
    <description>Recent content on KMS&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <managingEditor>개별설정 (개별설정)</managingEditor>
    <webMaster>개별설정 (개별설정)</webMaster>
    <lastBuildDate>Wed, 27 Oct 2021 22:00:00 +0900</lastBuildDate><atom:link href="https://kms-97.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>NodeJS - 쿠키와 세션</title>
      <link>https://kms-97.github.io/study/nodejs/nodejs_cookie/</link>
      <pubDate>Wed, 27 Oct 2021 22:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/nodejs/nodejs_cookie/</guid>
      <description>사용 이유 HTTP는 기본적으로 비연결성, 무상태성 특징을 가진다. 때문에 서버는 요청을 하는 클라이언트가 누구인지 기억하지 않으며 반복적인 인증을 필요로 한다. 이로 인한 속도 저하 이슈 또는 로그인 등의 상태 유지를 위해서 쿠키와 세션을 사용한다.
쿠키는 주로 다음와 같은 목적을 위해서 사용된다.
 세션 관리 로그인, 장바구니, 게임 스코어 등 정보 유지 개인화 사용자 선호, 테마 등의 세팅 트래킹 사용자의 행동을 기록 및 분석  쿠키 HTTP 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각.</description>
    </item>
    
    <item>
      <title>NodeJS - REST</title>
      <link>https://kms-97.github.io/study/nodejs/nodejs_rest/</link>
      <pubDate>Tue, 26 Oct 2021 22:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/nodejs/nodejs_rest/</guid>
      <description>REST REST란 REpresentational State Transfer의 줄임말로, 서버의 자원을 정의하고 자원에 대한 주소를 지정하는 방법이다. 통신 방식 중 하나로 일종의 약속이며, 구체적으로는 HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다. 즉, 어떤 자원에 대한 CRUD Operation 수행 요청을 URI에 보내는 것.
 URI(Uniform Resource Identifier)
&amp;lsquo;통합 자원 식별자&amp;rsquo;. 인터넷 상에서의 각종 정보들의 고유한 식별자이다. URI의 사전에 정의된 규칙에 따라 자원의 위치를 표시한 것을 URI, 이름을 표시한 것을 URN이라고 한다.</description>
    </item>
    
    <item>
      <title>NodeJS - HTTP</title>
      <link>https://kms-97.github.io/study/nodejs/nodejs_http/</link>
      <pubDate>Tue, 26 Oct 2021 20:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/nodejs/nodejs_http/</guid>
      <description>HTTP HyperText Transfer Protocol의 약자. 비순차적으로 연결된 하이퍼텍스트를 보다 빠르게 교환하기 위한 통신 규약이다. 즉, HTML을 포함한 JSON, XML, 이미지나 동영상과 같은 데이터를 서버와 클라이언트 사이에서 이루어질 요청 및 응답 방식을 정해둔 규칙이다. 프론트엔드 서버와 데이터베이스와 같은 백엔드 서버 간의 통신에도 사용된다. HTTP는 기본 포트로 80을 사용함.
by Yurim Koo
HTTPS란 HTTP에 보안성을 더한 것으로 HTTP에 over Secure Socket Layer가 붙는다. SSL 또는 TLS와 같은 인증 및 데이터 암호화 송수신 프로토콜을 사용한 것으로 암호화되지 않은 HTTP 프로토콜이 탈취, 변조 등의 위험에 노출된 것에 비해 안전하므로 전자상거래 또는 로그인 등이 필요한 사이트에서 주로 이용된다.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(7) - 게임 오버 팝업</title>
      <link>https://kms-97.github.io/project/react_blockgame7/</link>
      <pubDate>Tue, 12 Oct 2021 18:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame7/</guid>
      <description>게임 오버 팝업 띄우기 더 이상 블럭을 넣을 수 없을 때 나오는 팝업은 화면 전체를 가려야하기 때문에 root가 아닌 동등한 레벨의 새로운 노드로 넣어줘야 할 필요가 있었다. 이를 구현하기 위해 리액트의 Portals를 사용하기로 하였다.
팝업창 만들기 GameoverModel.js
import { useContext } from &amp;#39;react&amp;#39; import ReactDOM from &amp;#39;react-dom&amp;#39; import GameModeContext from &amp;#39;./context/GameMode&amp;#39; import GameScoreContext from &amp;#39;./context/GameScore&amp;#39; import &amp;#39;./GameoverModal.css&amp;#39; const GameoverModal = () =&amp;gt; { const gameMode = useContext(GameModeContext) const gameScore = useContext(GameScoreContext) const link = document.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(6) - 게임 오버</title>
      <link>https://kms-97.github.io/project/react_blockgame6/</link>
      <pubDate>Mon, 11 Oct 2021 18:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame6/</guid>
      <description>게임 오버 판별 블록을 게임판에 하나 둘 때마다, 남은 칸에 넣을 수 있는 블럭이 1개 이상 있는지 판별하여, 불가능한 경우 게임 오버로 판정해야한다.
그러려면 3개의 블럭 형태를 모두 게임판과 비교하여 확인해야하는데, 기존의 블럭 형태로는 어려워 생성 로직에 약간 수정이 필요했다.
블럭 생성 함수 수정 BlockUtil.js
const blockShape = [ [[1]], [[0,1],[1,1]], [[1,1],[1,1]], [[1,0,0],[1,1,1]], [[0,1,0],[1,1,1]], [[1],[1]], [[0,0,1],[1,1,1]], [[1,1,1]], [[0,0,1],[0,0,1],[1,1,1]], [[1,1,1],[0,0,1],[0,0,1]], [[1,1,1],[1,1,1],[1,1,1]], ] ... const rotateShape = (shape, rotate) =&amp;gt; { let rotated = [] const row = shape[0].</description>
    </item>
    
    <item>
      <title>NodeJS - 파일 시스템 접근하기</title>
      <link>https://kms-97.github.io/study/nodejs/nodejs_fs/</link>
      <pubDate>Tue, 05 Oct 2021 23:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/nodejs/nodejs_fs/</guid>
      <description>fs모듈 NodeJS에서 파일 시스템 접근을 위해서는 파일을 생성, 삭제, 수정이 가능한 fs 모듈을 사용한다.
대부분의 메소드들이 동기/비동기로 나뉘며, 동기방식의 메소드는 Sync라는 이름이 붙어있다.
동기적 방식을 사용하면 다른 작업을 동시에 수행할 수 없으며, 비동기적 방식은 다른 작업을 병행할 수 있으며 완료된 후 매개변수로 전달된 callback 함수를 호출한다. 비동기 방식은 항상 수행 완료시 호출될 callback 함수가 작성되어야 한다.
비동기 방식 파일 쓰기 main.mjs
import fs from &amp;#39;fs&amp;#39;; const text = &amp;#39;fs.writeFile test&amp;#39; fs.</description>
    </item>
    
    <item>
      <title>NodeJS - 모듈</title>
      <link>https://kms-97.github.io/study/nodejs/nodejs_%EB%AA%A8%EB%93%88/</link>
      <pubDate>Tue, 05 Oct 2021 21:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/nodejs/nodejs_%EB%AA%A8%EB%93%88/</guid>
      <description>모듈 기존의 NodeJS에서는 CommonJS 모듈 시스템을 채택하여 require()로 모듈을 사용했으나, 현재는 ES모듈을 지원하여 export import를 사용할 수 있다.
CommonJS CommonJS 방식을 통한 모듈 생성에는 두 가지 방법이 있다.
module.exports를 사용하는 방식과 exports를 사용하는 방법인데, 단일 객체를 내보내는 경우와 여러 객체를 내보내는 경우로 나누어 사용하게 된다.
require()을 통해 프로젝트 내부 모듈을 불러올 때는 확장자를 생략할 수 있다.
exports calculator.js
const add = (a, b) =&amp;gt; { return a + b }; const subtract = (a, b) =&amp;gt; { return a - b }; exports.</description>
    </item>
    
    <item>
      <title>Javscript - Promise, async/await</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4/</link>
      <pubDate>Wed, 29 Sep 2021 07:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4/</guid>
      <description>Promise Promise 객체는 두 개의 내부 프로퍼티를 갖는다.
 state : 진행 상태. pending(보류) / fulfilled(이행) / rejected(거부) / settled(완료)로 나뉨. result : 결과. 진행 중 revolve(value)를 만나면 value로, reject(error)를 만나면 error로 바뀜.  활용 const promise = (props) =&amp;gt; { return new Promise((revolve, reject) =&amp;gt; { // Do something...  if () {revolve(result)} reject(error) }) } // 프로미스 체이닝 promise(props).then((result) =&amp;gt; { // Do something...  return result }).then((result) =&amp;gt; { // Do something.</description>
    </item>
    
    <item>
      <title>Javscript - 클래스</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%ED%81%B4%EB%9E%98%EC%8A%A4/</link>
      <pubDate>Tue, 28 Sep 2021 23:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%ED%81%B4%EB%9E%98%EC%8A%A4/</guid>
      <description>클래스 자바스크립트에서의 클래스는 함수의 한 종류로, 생성자의 기능을 대체하여 상속을 보다 간결하게 작성할 수 있음.
별도의 문법을 사용하여 메소드 또는 프로퍼티 등을 선언할 수 있음.
단, 단순한 편의 문법이 아닌 다음과 같은 차이점을 가진다.
 반드시 new와 함께 사용해야 함. 클래스의 메서드는 열거할 수 없음. 즉, for...in을 통한 순회 시 메서드는 제외됨. 항상 엄격 모드(use strict)로 실행됨.  기본 문법 class User { //클래스 필드  isHuman = true; //생성자  constructor(name, age) { this.</description>
    </item>
    
    <item>
      <title>Javscript - 이터레이션 프로토콜</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98/</link>
      <pubDate>Tue, 28 Sep 2021 21:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98/</guid>
      <description>이터레이션 프로토콜 이터레이션 프로토콜(iteration protocol)은 데이터 컬렉션을 순회하기 위한 규칙.
이를 준수한 객체는 for...of로 순회 가능하고 Spread 문법의 피연산자가 될 수 있다.
이터러블 이터러블 프로토콜을 준수한 객체를 이터러블이라 하며, Symbol.iterator 메소드를 구현하거나 상속한 객체를 말한다.
배열은 이터러블이며, 일반 객체는 아니다.
const array = [1,2,3]; alert(Symbol.iterator in array); //true  const obj = {a:1, b:2, c:3}; alert(Symbol.iterator in obj); //false ES6에서 제공하는 빌트인 이터러블은 다음과 같다.
Array, String, Map, Set, TypedArray(Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,Int32Array, Uint32Array, Float32Array, Float64Array), DOM data structure(NodeList, HTMLCollection), Arguments 이터레이터 이터레이터 프로토콜은 next 메서드를 가지고 있어야 하며, next 메서드는 반복이 끝났는지에 대한 done 프로퍼티와 이터레이터로부터 반환되는 값인 value 프로퍼티를 갖는 객체를 반환해야 한다.</description>
    </item>
    
    <item>
      <title>Javscript - 생성자 함수와 프로토타입</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/</link>
      <pubDate>Tue, 28 Sep 2021 18:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/</guid>
      <description>생성자 함수 일반적으로 객체 리터럴 {...}을 통해 객체를 생성하지만, 유사한 객체를 여러 개 생성해야 할 때 new 연산자와 생성자 함수를 사용.
생성자 함수의 선언은 일반 함수와 큰 차이가 없지만 두 가지 관례를 따름.
 함수 이름의 첫 글자는 대문자로 시작. 반드시 new연산자를 붙여 실행.  function User(name, sex, age) { this.name = name; this.sex = sex; this.age = age; this.isAdmin = false; } let user = new User(&amp;#39;John&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;21&amp;#39;); alert(user.</description>
    </item>
    
    <item>
      <title>Javscript - 객체 프로퍼티</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EA%B0%9D%EC%B2%B4%EC%86%8D%EC%84%B1/</link>
      <pubDate>Tue, 28 Sep 2021 16:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EA%B0%9D%EC%B2%B4%EC%86%8D%EC%84%B1/</guid>
      <description>객체 프로퍼티 객체의 프로퍼티는 두 가지로 분류된다.
 데이터 프로퍼티 : 키와 값으로 분류된 일반적인 프로퍼티. 접근자 프로퍼티 : 자체적으로 값을 가지지 않고, 다른 데이터 프로퍼티의 값에 접근할 때 호출되는 접근자 함수(set, get)으로 구성된 프로퍼티  데이터 프로퍼티 데이터 프로퍼티는 값(value)과 함께 특별한 세 가지의 속성(플래그, flag)을 가짐.
 writable : 값 수정 enumerable : 반복을 통한 나열 configurable : 프로퍼티 삭제 또는 플래그 수정  일반적인 선언(지금까지 하던 객체 프로퍼티 선언)으로는 기본값인 true로 설정됨.</description>
    </item>
    
    <item>
      <title>Javscript - 객체</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EA%B0%9D%EC%B2%B4/</link>
      <pubDate>Wed, 15 Sep 2021 16:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EA%B0%9D%EC%B2%B4/</guid>
      <description>객체 선언 const obj = new Object() const obj = {} 두 방법에 큰 차이는 없으나 객체 리터럴 방법(2번째)이 가독성과 성능 등의 이유로 권장됨
프로퍼티 생성 const person = { name: &amp;#39;kim&amp;#39;, age: 25, } // 선언 시 입력  person.bloodtype = &amp;#39;A&amp;#39; // 동적 선언 프로퍼티의 값으로는 어떤 자료형이든 가능
const person ={ name: &amp;#39;kim&amp;#39;, age: 25, live: true, friends: [&amp;#39;song&amp;#39;, &amp;#39;ho&amp;#39;, &amp;#39;kang&amp;#39;], say: function(word) { alert(`${this.name}: ${word}`) } } 프로퍼티 접근 const person = { name: &amp;#39;kim&amp;#39;, age: 25, } person.</description>
    </item>
    
    <item>
      <title>Javscript - 연산자</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EC%97%B0%EC%82%B0%EC%9E%90/</link>
      <pubDate>Wed, 15 Sep 2021 16:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EC%97%B0%EC%82%B0%EC%9E%90/</guid>
      <description>이항 연산자    연산자 설명 예시     + 덧셈 연산자 2 + 3   - 뺄셈 연산자 7 - 2   * 곱셈 연산자 5 * 1   / 나눗셈 연산자 35 / 7   % 나머지 연산자 41 % 6   ** 제곱 연산자 3 ** 2    단항 연산자    연산자 설명 예시     + 단항 덧셈 연산자 +2</description>
    </item>
    
    <item>
      <title>Javscript - 자료형</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%EC%9E%90%EB%A3%8C%ED%98%95/</link>
      <pubDate>Wed, 15 Sep 2021 16:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%EC%9E%90%EB%A3%8C%ED%98%95/</guid>
      <description>원시형 숫자형 (2^53-1)부터 -(2^53-1)사이의 정수와 부동소수점 방식으로 표현된 실수
const int = 3; // 정수 선언 const float = 7.12; // 실수 선언 const floatToInt = parseInt(float); // 7 const intTofloat = int.toFixed(3); // &amp;#34;3.000&amp;#34; const StringToFloat = parseFloat(&amp;#39;6.84px&amp;#39;); // 6.84 const StringToInt = parseInt(&amp;#39;6.84px&amp;#39;); // 6 무한대(Infinity) Infinity 또는 -Infinity로 표현
const inf = 3/0; // Infinity const infDeclare = Infinity // 선언 inf === Infinify // true // 판별 isFinite(inf) // false NaN 아래의 경우 NaN을 반환</description>
    </item>
    
    <item>
      <title>Javscript - 함수</title>
      <link>https://kms-97.github.io/study/javascript/javascript_%ED%95%A8%EC%88%98/</link>
      <pubDate>Wed, 15 Sep 2021 16:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/study/javascript/javascript_%ED%95%A8%EC%88%98/</guid>
      <description>함수 자바스크립트에서 함수는 기본적인 구성 블럭 중 하나
함수 사용을 위해서는 함수를 호출하고자 하는 범위 내에서 정의해야함
선언 선언문 function 함수명(매개변수) { 함수 식 return 반환값 } 표현식 let myFucn = function(매개변수) { 함수 식 return 반환값 } 화살표 함수 표현식 let myFunc = (매개변수) =&amp;gt; { 함수 식 return 반환값 } let myFunc = 변수 =&amp;gt; 결과 // 인자가 하나라면 괄호 생략 가능 함수 선언문은 호이스팅되지만, 표현식은 인터프리터가 해당 줄에 도달해야 로드됨</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(5) - 점수 올리기</title>
      <link>https://kms-97.github.io/project/react_blockgame5/</link>
      <pubDate>Mon, 13 Sep 2021 19:10:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame5/</guid>
      <description>점수 기능 구현 게임판의 칸이 세로 또는 가로로 한 줄이 전부 채워지면 해당 줄을 지우고 점수를 올려야한다.
점수 관리 GameData.js
import React, { useState, createContext } from &amp;#34;react&amp;#34;; const GameDataContext = createContext({ state: { gamemode : 7, score : 0 }, actions : { setGamemode: () =&amp;gt; {}, setScore: () =&amp;gt; {}, } }) const GameDataProvider = ({ children }) =&amp;gt; { const [gamemode, setGamemode] = useState(7) const [score, setScore] = useState(0) const context = { state : { gamemode, score }, actions : { setGamemode, setScore } } return ( &amp;lt;GameDataContext.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(4) - 블럭 넣기 구현</title>
      <link>https://kms-97.github.io/project/react_blockgame4/</link>
      <pubDate>Sun, 12 Sep 2021 21:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame4/</guid>
      <description>게임판 상호작용 블럭을 드래그&amp;amp;드롭 할 때, 게임판 위에 위치하는지와 어느 칸에 삽입하는지를 알기 위해 게임판의 좌표를 가져와야할 필요가 있다.
ObjectList.js
... useEffect(() =&amp;gt; { const container = document.getElementById(&amp;#34;top-gameboard-container&amp;#34;) const boundary = container.getBoundingClientRect() return ( console.log(boundary) // 확인용  ) } ) ... useEffect를 사용하여 DOM이 렌더링되고 난 이후 게임판의 좌표를 getBoundingCilentRect() 통해서 가져오고자 했다.
결과는 에러였는데, 서로 다른 컴포넌트에서 렌더링되어 useEffect로 접근이 불가능한 듯하다. 이를 해결하기 위해서 context를 통한 전역변수로 사용하고자 했는데, 게임판의 좌표 외에 각 격자마다의 좌표, 삽입할 경우의 style 또는 state 변경 등을 생각하면 모두 context로 전달하기에는 너무 복잡해질 것 같았다.</description>
    </item>
    
    <item>
      <title>CodeUp 6077번~6091번 [기초-종합]</title>
      <link>https://kms-97.github.io/problem/codeup_6077~6091/</link>
      <pubDate>Fri, 10 Sep 2021 23:30:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/problem/codeup_6077~6091/</guid>
      <description>6077번 end = int(input()) result = 0 for i in range(0, end+1): if i%2 == 0: result+=i print(result) 6078번 while True: word = input() print(word) if word == &amp;#39;q&amp;#39;: break 6079번 limit = int(input()) value = 1 sum = 0 while True: sum += value if sum &amp;gt;= limit: print(value) break value += 1 6080번 a, b = map(int, input().split(&amp;#34; &amp;#34;)) for i in range(1, a+1): for j in range(1, b+1): print(i, end=&amp;#34; &amp;#34;) print(j) 6081번 value = int(input(), 16) for i in range(1, 16): print(&amp;#39;%X&amp;#39;%value, &amp;#39;*%X&amp;#39;%i, &amp;#39;=%X&amp;#39;%(value * i), sep=&amp;#34;&amp;#34;) 6082번 end = int(input()) for i in range(1, end+1): if (i%10) in [3, 6, 9]: print(&amp;#39;X&amp;#39;, end=&amp;#34; &amp;#34;) else: print(i, end=&amp;#34; &amp;#34;) 6083번 r, g, b = map(int, input().</description>
    </item>
    
    <item>
      <title>CodeUp 6063번~6076번 [기초-3항연산/조건-선택실행구조/반복실행구조]</title>
      <link>https://kms-97.github.io/problem/codeup_6063~6076/</link>
      <pubDate>Thu, 09 Sep 2021 23:26:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/problem/codeup_6063~6076/</guid>
      <description>6063번 a, b = map(int, input().split(&amp;#34; &amp;#34;)) print(a if (a&amp;gt;b) else b) 6064번 a, b, c = map(int, input().split(&amp;#39; &amp;#39;)) num1 = a if (a &amp;lt; b) else b num2 = c if (c &amp;lt; b) else b print(num1 if (num1 &amp;lt; num2) else num2) 6065번 a, b, c = map(int, input().split(&amp;#39; &amp;#39;)) if not bool(a%2) : print(a) if not bool(b%2) : print(b) if not bool(c%2) : print(c) 6066번 a, b, c = map(int, input().</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(3) - 블럭 만들기</title>
      <link>https://kms-97.github.io/project/react_blockgame3/</link>
      <pubDate>Thu, 09 Sep 2021 05:31:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame3/</guid>
      <description>블럭 오브젝트 만들기 줄곧 빈 칸으로 있던 ObjectList.js를 먼저 채워주기로 했다. 하나의 파일 안에 코드를 몰아넣으면 복잡해질 것 같아 생성하는 함수는 따로 작성하여 import 해주기로 했다.
ObjectUtil.js
const blockShape = [ [[1]], [[0,1],[1,1]], [[1,1],[1,1]], [[1,0,0],[1,1,1]], [[0,1,0],[1,1,1]], [[0,0,1],[1,1,1]], [[0,0,1],[0,0,1],[1,1,1]], [[1,1,1],[1,1,1],[1,1,1]], ] // 블럭 모양 설정  const blockColor = [ &amp;#39;black&amp;#39;, &amp;#39;gray&amp;#39;, &amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;purple&amp;#39;, &amp;#39;yellowgreen&amp;#39; ] // 블럭 색깔 설정  const rotate = [ 0, 90, 180, 270 ] // 블럭 회전  const randomNumber = () =&amp;gt; { return ({ shape: Math.</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(2) - Context API</title>
      <link>https://kms-97.github.io/project/react_blockgame2/</link>
      <pubDate>Thu, 09 Sep 2021 05:30:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame2/</guid>
      <description>Context API 도입 (1)에서 만들었던 화면에서는 게임 모드를 선택해도 게임판의 격자가 바뀌지 않았다. Gamemode.js의 state가 Gameboard.js로 전달되지 않아서인데, state를 공통 상위 컴포넌트로 올려도 되지만 이후 게임판의 좌표를 통해서 드래그&amp;amp;드롭되는 위치를 확인할 계획이기 때문에 컴포넌트 간 여러 변수를 공유할 계획으로 전역변수를 위한 Context API를 사용해 보기로 했다.
context/GameData.js
const GameDataContext = createContext({ state: { gamemode : 7, }, actions : { setGamemode: () =&amp;gt; {}, } }) const GameDataProvider = ({ children }) =&amp;gt; { const [gamemode, setGamemode] = useState(7) const context = { state : { gamemode }, actions : { setGamemode } } return ( &amp;lt;GameDataContext.</description>
    </item>
    
    <item>
      <title>CodeUp 6046번~6062번 [기초-비트시프트/비교/논리/비트단위논리 연산]</title>
      <link>https://kms-97.github.io/problem/codeup_6046~6062/</link>
      <pubDate>Wed, 08 Sep 2021 23:15:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/problem/codeup_6046~6062/</guid>
      <description>6046번 value = int(input()) print(value&amp;lt;&amp;lt;1) 6047번 a, b = map(int, input().split(&amp;#39; &amp;#39;)) print(a&amp;lt;&amp;lt;b) 6048번 a, b = map(int, input().split(&amp;#39; &amp;#39;)) print(a&amp;lt;b) 6049번 a, b = map(int, input().split(&amp;#39; &amp;#39;)) print(a==b) 6050번 a, b = map(int, input().split(&amp;#39; &amp;#39;)) print(a&amp;lt;=b) 6051번 a, b = map(int, input().split(&amp;#39; &amp;#39;)) print(a!=b) 6052번 print(bool(int(input()))) 6053번 print(not bool(int(input()))) 6054번 a, b = map(int, input().split()) print(bool(a) and bool(b)) 6055번 a, b = map(int, input().split()) print(bool(a) or bool(b)) 6056번 a, b = map(int, input().</description>
    </item>
    
    <item>
      <title>CodeUp 6032번~6045번 [기초-산술연산]</title>
      <link>https://kms-97.github.io/problem/codeup_6032~6045/</link>
      <pubDate>Tue, 07 Sep 2021 23:25:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/problem/codeup_6032~6045/</guid>
      <description>6032번 value = int(input()) print(-value) 6033번 value = ord(input()) print(chr(value + 1)) 6034번 a, b = input().split(&amp;#39; &amp;#39;) print(int(a) - int(b)) 6035번 f1, f2 = input().split(&amp;#39; &amp;#39;) print(float(f1) * float(f2)) 6036번 word, repeatValue = input().split(&amp;#39; &amp;#39;) print(word * int(repeatValue)) 6037번 repeatValue = int(input()) sentence = input() print(sentence * repeatValue) 6038번 a, b = input().split(&amp;#39; &amp;#39;) print(int(a) ** int(b)) 6039번 f1, f2 = input().split(&amp;#39; &amp;#39;) print(float(f1) ** float(f2)) 6040번 a, b = input().</description>
    </item>
    
    <item>
      <title>React로 블럭 채우기 퍼즐 만들기(1) - 시작, 화면 구성</title>
      <link>https://kms-97.github.io/project/react_blockgame1/</link>
      <pubDate>Mon, 06 Sep 2021 23:50:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/project/react_blockgame1/</guid>
      <description>시작 지난 번 작혼 확장프로그램을 리액트로 만들어 본 이후, 리액트와 자바스크립트에 좀 더 익숙해지고자 새로 시도해 볼 토이프로젝트를 고심하던 중 모바일 게임을 보고 구현해보고자 한다.
구상  게임 모드 버튼을 통해 게임판 크기 변경 가능 랜덤으로 생성되는 3가지의 블록을 드래그&amp;amp;드롭을 통해 배치 가로 또는 세로 한 줄이 다 차면 삭제 배치된 블럭 수, 삭제된 라인 또는 블럭 수 등으로 점수 표시  화면 구현 우선 간단하게 화면을 구성해보았다. 하나하나 기능을 구현해 갈 예정이다.</description>
    </item>
    
    <item>
      <title>CodeUp 6025번~6031, 6042번 [기초-값/출력변환]</title>
      <link>https://kms-97.github.io/problem/codeup_6025~60316042/</link>
      <pubDate>Mon, 06 Sep 2021 22:00:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/problem/codeup_6025~60316042/</guid>
      <description>6025번 a, b = input().split(&amp;#39; &amp;#39;) print(int(a)+int(b)) 6026번 a = input() b = input() print(float(a)+float(b)) 6027번 value = int(input()) print(&amp;#39;%x&amp;#39; %value) 6028번 value = int(input()) print(&amp;#39;%X&amp;#39; %value) 6029번 value = int(input(), 16) print(&amp;#39;%o&amp;#39; %value) 6030번 print(ord(input())) 6031번 print(chr(int(input()))) 6042번 value = float(input()) print(format(value, &amp;#39;.2f&amp;#39;)) </description>
    </item>
    
    <item>
      <title>CodeUp 6009번~6024번 [기초-입출력]</title>
      <link>https://kms-97.github.io/problem/codeup_6009~6024/</link>
      <pubDate>Sun, 05 Sep 2021 21:50:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/problem/codeup_6009~6024/</guid>
      <description>6009번 value = input() print(value) 6010번 value = int(input()) print(value) 6011번 value = float(input()) print(value) 6012번 value1 = input() value2 = input() print(value1, value2, sep=&amp;#34;\n&amp;#34;) 6013번 value1 = input() value2 = input() print(value2, value1, sep=&amp;#34;\n&amp;#34;) 6014번 value = input() print(value, value, value, sep=&amp;#34;\n&amp;#34;) 6015번 value1, value2 = input().split(&amp;#39; &amp;#39;) print(value1, value2, sep=&amp;#34;\n&amp;#34;) 6016번 value1, value2 = input().split(&amp;#39; &amp;#39;) print(value2, value1) 6017번 value = input() print(value, value, value) 6018번 value = input() print(value) 6019번 year, month, day = input().</description>
    </item>
    
    <item>
      <title>210905 CodeUp 6001번~6008번 [기초-출력]</title>
      <link>https://kms-97.github.io/problem/codeup_6001~6008/</link>
      <pubDate>Sun, 05 Sep 2021 02:06:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/problem/codeup_6001~6008/</guid>
      <description>6001번 print(&amp;#39;Hello&amp;#39;) 6002번 print(&amp;#39;Hello World&amp;#39;) 6003번 print(&amp;#39;Hello\nWorld&amp;#39;) 6004번 print(&amp;#34;&amp;#39;Hello World&amp;#39;&amp;#34;) 6005번 print(&amp;#39;&amp;#34;Hello World&amp;#34;&amp;#39;) 6006번 print(&amp;#34;\&amp;#34;!@#$%^&amp;amp;*()&amp;#39;&amp;#34;) 6007번 print(&amp;#34;\&amp;#34;C:\Download\\&amp;#39;hello&amp;#39;.py\&amp;#34;&amp;#34;) 6008번 print(&amp;#39;print(&amp;#34;Hello\\nWorld&amp;#34;)&amp;#39;) </description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://kms-97.github.io/about/</link>
      <pubDate>Sat, 04 Sep 2021 01:11:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/about/</guid>
      <description>공부하고 기록하는 블로그  웹 프로그래밍 동아리 &amp;ldquo;멋쟁이 사자처럼&amp;rdquo; 9기 코딩테스트 문제풀이 개인 프로젝트  </description>
    </item>
    
    <item>
      <title>Works</title>
      <link>https://kms-97.github.io/works/</link>
      <pubDate>Wed, 19 Oct 2016 22:35:00 +0900</pubDate>
      <author>개별설정 (개별설정)</author>
      <guid>https://kms-97.github.io/works/</guid>
      <description>Care U 스크린샷 소개 Github
멋쟁이 사자처럼 9기 4인 팀 아이디어톤 제출작
응급 상황 정보 제공 서비스 - &amp;ldquo;Care U&amp;rdquo;
기능  응급실/병원/약국의 위치, 운영시간, 병상 정보 등 기본 정보 제공 카테고리 별 병원 리스트 및 상세 정보 제공 챗봇 을 통한 진료 과목 고민 해결, 긴급 연락처, 응급 처치 등 정보 제공  개발 스택  Language      Framework   기여  프론트엔드 및 백엔드 전반  건강보험심사평가원 병원정보서비스 등 Open API를 통한 데이터베이스 구축 카카오 지도 Open API를 통한 현재 위치 및 지도 내 병원/약국/응급실 조회 AJAX를 통한 병원/약국/응급실 별 실시간 및 상세 정보 조회     작혼 어시스턴트 스크린샷 소개 Github</description>
    </item>
    
  </channel>
</rss>
